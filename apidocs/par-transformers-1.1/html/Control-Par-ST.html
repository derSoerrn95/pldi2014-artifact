<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Par.ST</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Par-ST.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">par-transformers-1.1: Extend Par monads with additional capabilities</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Control.Par.ST</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The monad: a dischargable effect
</a></li><li><a href="#g:2">An alternate fork operation 
</a></li><li><a href="#g:3">Working with ST and other lifts
</a></li><li><a href="#g:4">Convert between state types
</a></li><li><a href="#g:5">Type class for valid states.
</a></li><li><a href="#g:6">Annoying newtypes and wrappers to take the <code>s</code> param last:
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This file provides a basic capability for parallel in-place modification of
 (disjoint) partitions of an array.  It allows a <code>Par</code> computation to carry an
 implicit vector in the background, which allows mutation via arbitrary <code><a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad-ST-Safe.html#t:ST">ST</a></code>
 computations.
</p><p>This module does NOT provide a monad-transformer.  Rather, it is a ROOT for a
 monad-transformer stack, and is hard-wired to use the <a href="Control-LVish.html">Control.LVish</a> version of
 the <code>Par</code> monad underneath.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:ParST">ParST</a> stState parM ans</li><li class="src short"><a href="#v:runParST">runParST</a> :: <span class="keyword">forall</span> stt s0 parM ans. <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; stt s0 -&gt; (<span class="keyword">forall</span> s1.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s1) parM ans) -&gt; parM ans</li><li class="src short"><a href="#v:forkSTSplit">forkSTSplit</a> :: <span class="keyword">forall</span> a b s0 parM stt. (<a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM, <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParFuture">ParFuture</a> parM, <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:FutContents">FutContents</a> parM a, <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> stt) =&gt; <a href="Control-Par-ST.html#t:SplitIdx">SplitIdx</a> stt -&gt; (<span class="keyword">forall</span> sl.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt sl) parM a) -&gt; (<span class="keyword">forall</span> sr.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt sr) parM b) -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s0) parM (a, b)</li><li class="src short"><a href="#v:liftST">liftST</a> :: <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad-ST-Safe.html#t:ST">ST</a> s1 a -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s1) parM a</li><li class="src short"><a href="#v:liftPar">liftPar</a> :: <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; parM a -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> stt1 parM a</li><li class="src short"><a href="#v:transmute">transmute</a> :: <span class="keyword">forall</span> a b s parM ans. (<a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> b) =&gt; (b s -&gt; a s) -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (a s) parM ans -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (b s) parM ans</li><li class="src short"><span class="keyword">class</span>  <a href="#t:STSplittable">STSplittable</a> ty  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:SplitIdx">SplitIdx</a> ty :: *</li><li><a href="#v:splitST">splitST</a> ::  <a href="Control-Par-ST.html#t:SplitIdx">SplitIdx</a> ty -&gt; ty s -&gt; (ty s, ty s)</li></ul></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:MVectorFlp">MVectorFlp</a> a s = <a href="#v:VFlp">VFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Mutable.html#t:MVector">MVector</a> s a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:UVectorFlp">UVectorFlp</a> a s = <a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Unboxed.html#t:Unbox">Unbox</a> a =&gt; <a href="#v:UFlp">UFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Unboxed.html#t:MVector">MVector</a> s a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:SVectorFlp">SVectorFlp</a> a s = <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; <a href="#v:SFlp">SFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Storable-Mutable.html#t:MVector">MVector</a> s a)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:STTup2">STTup2</a> a b s = <a href="#v:STTup2">STTup2</a> !(a s) !(b s)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:STUnit">STUnit</a> s = <a href="#v:STUnit">STUnit</a></li></ul></div><div id="interface"><h1 id="g:1">The monad: a dischargable effect
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ParST" class="def">ParST</a> stState parM ans </p><div class="doc"><p>The ParST monad.  It uses the StateT monad transformer to layer
 a state of type on top of an inner monad, <code><a href="Control-LVish.html#t:Par">Par</a></code>.
</p><p>The first type parameter determines the type of state held.  The parameters <code>det</code>
 and <code>s2</code> are for the underlying <code>Par</code> monad.
</p><p>Its final parameter, <code>ans</code>, is the result of running the entire computation, after
 which the vector is no longer accessible.
</p></div><div class="subs instances"><p id="control.i:ParST" class="caption collapser" onclick="toggleSection('i:ParST')">Instances</p><div id="section.i:ParST" class="show"><table><tr><td class="src"><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; <a href="file:///Library/Haskell/ghc-7.6.3/lib/mtl-2.1.2/doc/html/Control-Monad-State-Class.html#t:MonadState">MonadState</a> stts (<a href="Control-Par-ST.html#t:ParST">ParST</a> stts parM)</td><td class="doc"><p>We use the generic interface for <code>put</code> and <code>get</code> on the entire (mutable) state.
</p></td></tr><tr><td class="src"><a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> parM =&gt; <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Monad">Monad</a> (<a href="Control-Par-ST.html#t:ParST">ParST</a> stState parM)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> parM =&gt; <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad.html#t:Functor">Functor</a> (<a href="Control-Par-ST.html#t:ParST">ParST</a> stState parM)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParFuture">ParFuture</a> parM =&gt; <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParFuture">ParFuture</a> (<a href="Control-Par-ST.html#t:ParST">ParST</a> sttt parM)</td><td class="doc"><p>A conditional instance which will only be usable if unsafe imports are made.
 instance MonadIO parM =&gt; MonadIO (ParST stt1 parM) where
   liftIO io = ParST (liftIO io)
</p><p>An instance of <code>ParFuture</code> for <code>ParST</code> _does_ let us do arbitrary <code><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#v:fork">fork</a></code>s at the
 <code>ParST</code> level, HOWEVER the state is inaccessible from within these child computations.
</p></td></tr><tr><td class="src"><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParIVar">ParIVar</a> parM =&gt; <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParIVar">ParIVar</a> (<a href="Control-Par-ST.html#t:ParST">ParST</a> sttt parM)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParMonad">ParMonad</a> parM =&gt; <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParMonad">ParMonad</a> (<a href="Control-Par-ST.html#t:ParST">ParST</a> stt1 parM)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runParST" class="def">runParST</a> :: <span class="keyword">forall</span> stt s0 parM ans. <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; stt s0 -&gt; (<span class="keyword">forall</span> s1.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s1) parM ans) -&gt; parM ans</p><div class="doc"><p><code>runParST</code> discharges the extra state effect leaving the the underlying <code>Par</code>
 computation only -- just like <code>runStateT</code>.  Here, using the standard trick
 runParST has a rank-2 type, with a phantom type <code>s1</code>.
</p></div></div><h1 id="g:2">An alternate fork operation 
</h1><div class="top"><p class="src"><a name="v:forkSTSplit" class="def">forkSTSplit</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> a b s0 parM stt . (<a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM, <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:ParFuture">ParFuture</a> parM, <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class.html#t:FutContents">FutContents</a> parM a, <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Data-Eq.html#t:Eq">Eq</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> stt)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Control-Par-ST.html#t:SplitIdx">SplitIdx</a> stt</td><td class="doc"><p>Where to split the data.
</p></td></tr><tr><td class="src">-&gt; (<span class="keyword">forall</span> sl.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt sl) parM a)</td><td class="doc"><p>Left child computation.
</p></td></tr><tr><td class="src">-&gt; (<span class="keyword">forall</span> sr.  <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt sr) parM b)</td><td class="doc"><p>Right child computation.
</p></td></tr><tr><td class="src">-&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s0) parM (a, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code>forkWithVec</code> takes a split point and two ParST computations.  It
 gets the state of the current computation, for example a vector, and
 then divides up that state between the two other computations.
</p><p>Writes in those two computations may actually mutate the original vector.  But
 <code>forkWithVec</code> is a fork-join construct, rather than a one-sided fork such as
 <code><a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#v:fork">fork</a></code>.  So the continuation of <code>forkWithVec</code> will not run until both child
 computations return, and are thus done accessing the state.
</p></div></div><h1 id="g:3">Working with ST and other lifts
</h1><div class="top"><p class="src"><a name="v:liftST" class="def">liftST</a> :: <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; <a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad-ST-Safe.html#t:ST">ST</a> s1 a -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (stt s1) parM a</p><div class="doc"><p>Allow <code><a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Control-Monad-ST-Safe.html#t:ST">ST</a></code> computations inside <code><a href="Control-Par-ST.html#t:ParST">ParST</a></code> computations.
   This operation has some overhead. 
</p></div></div><div class="top"><p class="src"><a name="v:liftPar" class="def">liftPar</a> :: <a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM =&gt; parM a -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> stt1 parM a</p><div class="doc"><p>Lift an ordinary <code>Par</code> computation into <code><a href="Control-Par-ST.html#t:ParST">ParST</a></code>.
</p></div></div><h1 id="g:4">Convert between state types
</h1><div class="top"><p class="src"><a name="v:transmute" class="def">transmute</a> :: <span class="keyword">forall</span> a b s parM ans. (<a href="file:///ffh/ryan/cloud_drive/working_copies/pldi2014-artifact/LVish_repo/haskell/par-transformers/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.6.3/par-classes-1.1/html/Control-Par-Class-Unsafe.html#t:ParThreadSafe">ParThreadSafe</a> parM, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> b) =&gt; (b s -&gt; a s) -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (a s) parM ans -&gt; <a href="Control-Par-ST.html#t:ParST">ParST</a> (b s) parM ans</p></div><h1 id="g:5">Type class for valid states.
</h1><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:STSplittable" class="def">STSplittable</a> ty  <span class="keyword">where</span></p><div class="doc"><p>The class of types that can be modified in ST computations, and whose state can
 be partitioned into disjoint pieces to be passed linearly to exactly one parallel
 subcomputation.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:SplitIdx" class="def">SplitIdx</a> ty :: *</p><div class="doc"><p>Something of type <code><a href="Control-Par-ST.html#t:SplitIdx">SplitIdx</a></code> describes where and how to split the data into two pieces.
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:splitST" class="def">splitST</a> ::  <a href="Control-Par-ST.html#t:SplitIdx">SplitIdx</a> ty -&gt; ty s -&gt; (ty s, ty s)</p><div class="doc"><p><code><a href="Control-Par-ST.html#v:splitST">splitST</a></code> does the actual splitting.
</p></div></div><div class="subs instances"><p id="control.i:STSplittable" class="caption collapser" onclick="toggleSection('i:STSplittable')">Instances</p><div id="section.i:STSplittable" class="show"><table><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> <a href="Control-Par-ST.html#t:STUnit">STUnit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:SVectorFlp">SVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:UVectorFlp">UVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:MVectorFlp">MVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> b) =&gt; <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:STTup2">STTup2</a> a b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:6">Annoying newtypes and wrappers to take the <code>s</code> param last:
</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:MVectorFlp" class="def">MVectorFlp</a> a s </p><div class="doc"><p>The ways to split a vector.  For now we only allow splitting into two pieces at a
 given index.  In the future, other ways of partitioning the set of elements may be
 possible.
 newtype VecSplit = SplitAt Int
</p><p>An annoying type alias simply for the purpose of arranging for the <code>s</code> parameter
 to be last.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:VFlp" class="def">VFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Mutable.html#t:MVector">MVector</a> s a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:MVectorFlp" class="caption collapser" onclick="toggleSection('i:MVectorFlp')">Instances</p><div id="section.i:MVectorFlp" class="show"><table><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:MVectorFlp">MVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:UVectorFlp" class="def">UVectorFlp</a> a s </p><div class="doc"><p>An annoying type alias simply for the purpose of arranging for the <code>s</code> parameter
 to be last.  Also carries the <code>Unbox</code> constraint.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Unboxed.html#t:Unbox">Unbox</a> a =&gt; <a name="v:UFlp" class="def">UFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Unboxed.html#t:MVector">MVector</a> s a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:UVectorFlp" class="caption collapser" onclick="toggleSection('i:UVectorFlp')">Instances</p><div id="section.i:UVectorFlp" class="show"><table><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:UVectorFlp">UVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:SVectorFlp" class="def">SVectorFlp</a> a s </p><div class="doc"><p>An annoying type alias simply for the purpose of arranging for the <code>s</code> parameter
 to be last.  Also carries the <code>Storable</code> constraint.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a href="file:///Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/share/doc/ghc/html/libraries/base-4.6.0.1/Foreign-Storable.html#t:Storable">Storable</a> a =&gt; <a name="v:SFlp" class="def">SFlp</a> (<a href="file:///Library/Haskell/ghc-7.6.3/lib/vector-0.10.0.1/doc/html/Data-Vector-Storable-Mutable.html#t:MVector">MVector</a> s a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:SVectorFlp" class="caption collapser" onclick="toggleSection('i:SVectorFlp')">Instances</p><div id="section.i:SVectorFlp" class="show"><table><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:SVectorFlp">SVectorFlp</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:STTup2" class="def">STTup2</a> a b s </p><div class="doc"><p>An annoying type wrapper simply for the purpose of arranging for the <code>s</code> parameter
 to be last.  
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:STTup2" class="def">STTup2</a> !(a s) !(b s)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:STTup2" class="caption collapser" onclick="toggleSection('i:STTup2')">Instances</p><div id="section.i:STTup2" class="show"><table><tr><td class="src">(<a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> a, <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> b) =&gt; <a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> (<a href="Control-Par-ST.html#t:STTup2">STTup2</a> a b)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:STUnit" class="def">STUnit</a> s </p><div class="doc"><p>A splittable type which contains no information.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:STUnit" class="def">STUnit</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:STUnit" class="caption collapser" onclick="toggleSection('i:STUnit')">Instances</p><div id="section.i:STUnit" class="show"><table><tr><td class="src"><a href="Control-Par-ST.html#t:STSplittable">STSplittable</a> <a href="Control-Par-ST.html#t:STUnit">STUnit</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>